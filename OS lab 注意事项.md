# OS lab 注意事项

> 一些调试方面的东西，记录一下。

## lab 3

1. 实验文档2.1.3里面的1.3.1其实是3.3.1

2. 2.3 func2 部分使用方法见4.8 应当是2.9

3. lab3的part1，mm_malloc默认调用first fit，但我们两个都要写。所以，是允许我们现场修改mm.c重新编译，还是要在workload中实现用户自由选择分配算法？

   - 允许现场修改mm.c并重新编译

4. https://docs.qq.com/sheet/DU3BzV1JZT3d2U2Vi?tab=14g1be **共享文档**也更新了实验三的部分，欢迎大家提问。

5. 实验三使用Ubuntu 22.04，或者5.18版本以上内核实验的同学make modules_install 可能会遇到问题，解决方法已在共享文档里给出。

6. func 1/2/3各1分，func 4/5 共1分，报告1分，代码讲解1分。满分6分。【得分标准】

7. 实验三part2的func 4和func 5的主要区别在于打印数据的起始地址和结束地址不一样，各位同学完成时注意一下

8. > wym 2023/5/23 10:14:20
   > 蓝色的梦   active_page_log.txt
   > @助教-姚路路 这个的意思是只输出active page的地址值吗
   >
   > wym 2023/5/24 0:12:23
   > function5为什么找第二个vma不能找到数据呢
   >
   > 蓝色的梦 2023/5/24 11:10:18
   > 请问扫描第二个vma的时候可以得到相应的page吗？
   >
   > wym 2023/5/24 11:13:38
   > 第二个vma不是也指向了相应的page吗，我得到其中的虚拟地址找到物理地址按理来说也是一样的吧
   >
   > 蓝色的梦 2023/5/24 11:15:23
   > 是一样的，我的意思是第二个vma有得到page，而且page不为NULL，并且这个page是属于代码段的。按理说，func 4完成没问题的话，func 5只需要修改一下起始和终止虚拟地址，其他操作一样
   >
   > wym 2023/5/24 11:21:28
   > 主要是我一开始这么干，打出来都是乱码，结果用mm_struct描述的start_data才能打出来，比较困惑
   >
   > 蓝色的梦 2023/5/24 11:22:28
   > 代码段打印的结果确实都是乱码，是正常的。数据段会打印出字符串
   >
   > wym 2023/5/24 11:27:38
   > 我用func3遍历所有虚拟页面的方法把每一页打出来好像也没找到数据段
   >
   > 蓝色的梦 2023/5/24 11:28:19
   > 数据段的起始和结束地址在mm_struct中
   >
   > wym 2023/5/24 11:29:33
   > 好吧![img](file:///C:\Users\MinervaZH\AppData\Roaming\Tencent\QQTempSys\09O%LI_1[_I5QD8}PJDQWMV.gif)

9. `brk()` 是一个底层的系统调用，用于更改进程的堆空间的结束地址。它是一种用于动态内存分配的机制，允许进程在运行时请求增加或减少其堆空间的大小。

   在 Linux 系统中，`brk()` 系统调用可以通过将堆的结束地址设置为新的值来改变进程的堆空间大小。堆是一块用于动态分配内存的连续地址空间。通过调用 `brk()` 并传递新的结束地址作为参数，进程可以将堆的大小增加或减少到所需的大小。

   `brk()` 系统调用的原型如下：

   ```c
   #include <unistd.h>
   
   int brk(void *addr);
   ```

   `addr` 参数指定了新的堆结束地址。如果该参数大于当前的堆结束地址，则堆的大小将增加；如果该参数小于当前的堆结束地址，则堆的大小将减少。`brk()` 函数成功时返回 0，否则返回 -1。

   需要注意的是，`brk()` 只能增加或减少堆的结束地址，并不关心具体的分配或释放的字节数。因此，在使用 `brk()` 进行内存分配时，需要自己实现内存管理机制来跟踪分配和释放的内存块，以确保正确的内存使用和防止内存泄漏。

   现代的应用程序通常会使用更高级别的内存分配函数，如 `malloc()` 和 `free()`，它们在底层使用 `brk()` 等系统调用来分配和释放内存。这些高级别函数提供了更方便和易用的接口，并提供了更多的功能，如内存池管理、内存对齐等。

10. `sbrk()` 是一个系统调用，用于在程序运行时扩展或缩小进程的堆空间。它可以改变进程的堆空间的大小，从而允许动态地分配内存。

   在C语言中，当我们需要在堆上动态分配内存时，通常会使用`malloc()`和`free()`函数。这些函数在底层会使用`sbrk()`系统调用来获取额外的内存。`sbrk()` 的原型如下：

   ```c
   void *sbrk(intptr_t increment);
   ```

   `sbrk()` 接受一个参数 `increment`，表示需要增加或减少的内存字节数。`increment` 可以是正数或负数。当 `increment` 为正数时，`sbrk()` 会增加堆的大小，返回指向新分配内存的指针。当 `increment` 为负数时，`sbrk()` 会减小堆的大小，返回指向释放内存的指针。如果调用 `sbrk()` 失败，它将返回 `(void *) -1`。

   `sbrk()` 函数通过增加或减少堆的大小来满足对内存的请求。这意味着它改变了进程的堆空间的边界，以适应新的内存需求。通常，操作系统将堆空间放在进程的数据段和栈段之间。

   需要注意的是，`sbrk()` 并不是一个线程安全的函数，因此在多线程的环境中应该谨慎使用。在现代操作系统中，使用更高级别的内存分配函数（如`malloc()`和`free()`）会更加可靠和方便，而不直接调用`sbrk()`.

```
```



